import numpy as np
import pandas as pd
import math
from matplotlib import pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.arima_model import ARIMA
from pandas.plotting import register_matplotlib_converters
from sklearn.metrics import mean_squared_error
register_matplotlib_converters()

# citim datele din csv
df = pd.read_csv('Hungary.csv', parse_dates = ['DATE'], index_col = ['DATE'])
size = 216
X = df.values
train = X[0:size]
test= X[size:len(X)]
df_train = df.head(size)
df_test = df.tail(36)

fig, ax = plt.subplots(1, 3, figsize=(18,3))
ax[0].plot(df_train)
ax[0].set_title('Training data')
plot_acf(df_train, lags=25, ax=ax[1])
plot_pacf(df_train, lags=25, ax=ax[2])

df_log = np.log(df_train)

x=df_train['VALUE']
result=adfuller(x)
print("ADF Stataics ",result[0])
print("p-value",result[1])
print("critical values",result[5])
if result[1]<=0.05:
    print("fail to reject null hypothese h1, it means data is stationary")
else:
    print("Reject the null hypothese, it means data is not stationary")

df_train_first_diff=df_train['VALUE']-df_train['VALUE'].shift(1)
df_train_first_diff=df_train_first_diff.dropna()

result=adfuller(df_train_first_diff)
print("ADF Stataics ",result[0])
print("p-value",result[1])
print("critical values",result[5])
if result[1]<=0.05:
    print("Fail to reject null hypothese h1, it means data is stationary")
else:
    print("Reject the null hypothese, it means data is not stationary")

fig, ax = plt.subplots(1, 3, figsize=(18,3))
ax[0].plot(df_train_first_diff)
plot_acf(df_train_first_diff.iloc[1:], lags=25, ax=ax[1])
plot_pacf(df_train_first_diff, lags=25, ax=ax[2])

diff_1 = df_train.diff().dropna()
print("p-value:", adfuller(diff_1)[1])

df_train.index = pd.DatetimeIndex(df_train.index.values, freq=df_train.index.inferred_freq)
res = ARIMA(df_train, (4, 1, 4)).fit()
print(res.summary())

residuals = pd.DataFrame(res.resid)
residuals.plot()
residuals.plot(kind='kde')
plt.show()
print(residuals.describe())

plot_acf(residuals, lags=25)

fc, se, conf = res.forecast(36, alpha=0.05)  # 95% conf

# Make as pandas series
fc_series = pd.Series(fc, index=df_test.index)
lower_series = pd.Series(conf[:, 0], index=df_test.index)
upper_series = pd.Series(conf[:, 1], index=df_test.index)

# Plot
plt.figure(figsize=(12,5), dpi=100)
plt.plot(df_train, label='training')
plt.plot(df_test, label='actual')
plt.plot(fc_series, label='forecast')
plt.fill_between(lower_series.index, lower_series, upper_series, color='k', alpha=.15)
plt.title('Forecast vs Actuals')
plt.legend(loc='upper left', fontsize=8)
plt.show()

def forecast_accuracy(forecast, actual):
    mape = np.mean(np.abs(forecast - actual)/np.abs(actual))  # MAPE
    me = np.mean(forecast - actual)             # ME
    mae = np.mean(np.abs(forecast - actual))    # MAE
    mpe = np.mean((forecast - actual)/actual)   # MPE
    rmse = np.mean((forecast - actual)**2)**.5  # RMSE
    corr = np.corrcoef(forecast, actual)[0,1]   # corr
    mins = np.amin(np.hstack([forecast[:,None], 
                              actual[:,None]]), axis=1)
    maxs = np.amax(np.hstack([forecast[:,None], 
                              actual[:,None]]), axis=1)
    minmax = 1 - np.mean(mins/maxs)             # minmax
    return({'mape':mape, 'me':me, 'mae': mae, 
            'mpe': mpe, 'rmse':rmse, 
            'corr':corr, 'minmax':minmax})

forecast_accuracy(fc, df_test.VALUE)

history = [x for x in train]
model_predictions = []
N_test_observations = len(df_test)
for time_point in range(N_test_observations):
    model = ARIMA(history, order=(4, 1, 4))
    model_fit = model.fit()
    output = model_fit.forecast()
    yhat = output[0]
    model_predictions.extend(yhat)
    true_test_value = test[time_point]
    history.append(true_test_value)

print('AIC=%f' % model_fit.aic)

fc1 = np.array(model_predictions)
print(forecast_accuracy(fc1, df_test.VALUE))

for time_point in range(36):
    model = ARIMA(history, order=(4, 1, 4))
    model_fit = model.fit()
    output = model_fit.forecast()
    yhat = output[0]
    model_predictions.append(yhat)
    history.append(yhat)
    print('predicted=%f' % yhat)

plt.plot(test, label='Actual')
plt.plot(model_predictions, color='red', label='Predicted')
plt.legend(loc='best')
plt.title('Hungary')
plt.show()